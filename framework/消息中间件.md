# 消息中间件

## 消息模型

- 点对点
  - 每个消息只有一个消费者
  - 发送者和接受者没有时间依赖
  - 接受者确认消息处理
- 发布／订阅
  - 每个消息可以有多个订阅者
  - 客户端只有订阅后才能收到消息
  - 持久订阅与非持久订阅
  - 当只有一个订阅者时近似为点对点

## 消息应用场景

- 解耦／异步
- 消息有序性
- 分布式事务／一致性
- 流量控制／错峰
- 日志
  - 流量大，吞吐量高
  - 如nginx日志
- 业务
  - 高可靠，敏感型
  - 如im消息，通知，push推送

## message delivery guaranteeing

- 最多一次:消息可能会丢，但绝不会重复传输
- 最少一次:消息绝不会丢，但可能会重复传输（kafka，分布式mq）
- 只有一次:每条消息肯定会被传输一次且仅传输一次（rabbitmq）

## 消息分发模型

- 推模型：消息延时低，实时性要求高
- 拉模型：生产端速率远大于消费端（大量消息堆积）

| 消费模型与功能特性 | Push模型                                   | Pull模型                                   |
| --------- | ---------------------------------------- | ---------------------------------------- |
| 消费行为      | 服务端主动发送数据给客户端                            | 消费端主动从服务端拉取数据，通常客户端会定时拉取                 |
| 实时性       | 较好，服务端收到数据后可立即转发送给消费端                    | 一般，取决于pull的间隔时间                          |
| 服务端状态     | 服务端需要记录每个客户端对topic的订阅关系，也要记录发送状态，逻辑较为复杂。 | 服务端无状态，逻辑较为简单                            |
| 消费端状态     | 无需额外保存状态                                 | 需保存当前拉取的信息的状态，以便在故障或者重启时恢复               |
| 状态保存      | 集中式，集中在服务端                               | 分布式，分散在各个消费端                             |
| 负载均衡      | 服务端统一处理和控制                               | 消费端之间做分配，需要协调机制，如使用一个nameServer或zookeeper管理和控制 |
| 对服务端影响    | 服务端需要做流量控制，无法最大化消费端的处理能力，其次，在消费端故障的情况下，无效的push对服务端有一定负载。 | 消费端的请求可能很多无效或者没有数据可供传输，浪费带宽和服务器处理能力      |

## RabbitMQ逻辑架构

- 优点
  - 插件机制
  - 可以定制开发
  - 过载保护机制，内存占用或磁盘占用超过阈值流控机制
  - 支持消息粒度的生产和消费控制以及状态管理
  - 支持预取批量消息
  - 完善的生态圈，还有友好的管理平台
- 劣势
  - 伪分布式设计
  - 消息堆积能力弱
  - 不支持批量生产消息
  - 性能差，每写一条消息涉及三次io操作
  - 资源消耗多（cpu消耗高，内存占用多）